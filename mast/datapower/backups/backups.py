"""==========================================================
mast backups:

A set of tools for automating routine backup/checkpoint
related tasks associated with IBM DataPower appliances.

Copyright 2014, All Rights Reserved
McIndi Solutions LLC
=========================================================="""
import os
import flask
import zipfile
import commandr
from time import time, sleep
from mast.plugins.web import Plugin
from mast.datapower import datapower
from mast.timestamp import Timestamp
from mast.logging import make_logger, logged
import mast.plugin_utils.plugin_utils as util
from functools import partial, update_wrapper
import mast.plugin_utils.plugin_functions as pf


class TimeoutError(Exception):
    pass


cli = commandr.Commandr()


@logged("mast.datapower.backups")
def _verify_zip(zip_file):
    if isinstance(zip_file, basestring):
        try:
            zip_file = zipfile.ZipFile(zip_file, "r")
        except zipfile.BadZipfile:
            return False
    if zip_file.testzip() is None:
        # if testzip returns None then there were no errors
        zip_file.close()
        return True
    return False


@logged("mast.datapower.backups")
def _create_dir(base_dir, hostname, timestamp):
    directory = os.path.join(base_dir, hostname, timestamp)
    os.makedirs(directory)
    return directory


# ~#~#~#~#~#~#~#
# backups/checkpoints
# ===================
#
# These functions are meant to work with the backups and checkpoints of
# the specified appliances
#
# current commands
# ----------------
# normal-backup - Performs a normal backup of the specified domains on
#                 the specified appliances
# secure-backup - Performs a secure backup of the specified appliances
# verify-secure-backup - Verifies a secure backup based on the checksums of
#                        the files in backupmanifest.xml
# set-checkpoint - Sets a checkpoint in the given domain on the
#                  given appliances


@logged("mast.datapower.backups")
@cli.command('restore-normal-backup', category='backups')
def restore_normal_backup(appliances=[], credentials=[], timeout=120,
                          file_in=None, Domain="", source_type="ZIP",
                          overwrite_files=True, overwrite_objects=True,
                          rewrite_local_ip=True, deployment_policy=None,
                          import_domain=True, reset_domain=True,
                          dry_run=False, out_dir="tmp",
                          no_check_hostname=False, web=False):
    """Restores a normal backup to the specified appliances and Domains.

Parameters:

* file_in - The backup file which will be restored. This must be in the
format specified in source_type
* Domain - The domain to which to restore the backup
* source_type - The type of backup, must be either "ZIP" or "XML"
* overwrite_files - Whether to overwrite files when restoring the backup
* overwrite_objects - Whether to overwrite objects when restoring
the backup
* rewrite_local_ip - Whether to rewrite the local IP Addresses
* deployment_policy - The deployment policy to apply when restoring
the backup
* import_domain - Whether we are importing a domain
* reset_domain - Whether to reset the domain
* dry_run - Whether this should be a dry-run
* out_dir - (NOT NEEDED IN WEB GUI) The directory (local) where you would
want all of the files generated by the restore to be placed
"""
    logger = make_logger("mast.backups")
    t = Timestamp()
    check_hostname = not no_check_hostname
    env = datapower.Environment(
        appliances,
        credentials,
        timeout,
        check_hostname=check_hostname)
    logger.info(
        "Attempting to restore normal backup on {} in {} domain".format(
            str(env.appliances), Domain))

    kwargs = {
        "file_in": file_in,
        "source_type": source_type,
        "domain": Domain,
        "overwrite_files": overwrite_files,
        "overwrite_objects": overwrite_objects,
        "rewrite_local_ip": rewrite_local_ip,
        "deployment_policy": deployment_policy,
        "import_domain": import_domain,
        "reset_domain": reset_domain,
        "dry_run": dry_run}

    resp = env.perform_action("restore_normal_backup", **kwargs)
    logger.debug("Responses received {}".format(str(resp)))

    out_dir = os.path.join(out_dir, "restore_normal_backup", t.timestamp)
    os.makedirs(out_dir)

    for host, r in resp.items():
        filename = os.path.join(out_dir, "{}-{}-{}-results.xml".format(
            t.timestamp,
            host,
            Domain))
        with open(filename, 'wb') as fout:
            fout.write(r.pretty)
    if web:
        return util.render_see_download_table(resp), util.render_history(env)


@logged("mast.datapower.backups")
@cli.command('do-normal-backup', category='backups')
def get_normal_backup(appliances=[], credentials=[],
                      timeout=120, Domain=[],
                      comment="", out_dir='tmp',
                      no_check_hostname=False, web=False):
    """Performs a normal backup of the specified domain.

Parameters:

* Domain - The domains to backup (all-domains will backup all domains)
* out_dir - (NOT NEEDED IN WEB GUI) The directory (local) where you
would like to store the backup
"""
    logger = make_logger("mast.backups")
    t = Timestamp()
    check_hostname = not no_check_hostname
    env = datapower.Environment(
        appliances,
        credentials,
        timeout,
        check_hostname=check_hostname)

    if isinstance(Domain, basestring):
        Domain = [Domain]
    # Fixes duplicate domains issue
    Domain = list(set(Domain))

    results = {}
    for domain in Domain:
        logger.info(
            "Attempting to retrieve normal backup from "
            "{} in {} domain".format(str(env.appliances), domain))
        kwargs = {'domain': domain, 'comment': comment}
        _results = env.perform_async_action('get_normal_backup', **kwargs)
        logger.debug("backups retrieved, check file for contents")

        for hostname, backup in _results.items():
            directory = os.path.join(
                out_dir,
                hostname,
                "NormalBackup",
                domain,
                t.timestamp)
            os.makedirs(directory)
            filename = os.path.join(
                directory,
                '%s-%s-%s.zip' % (
                    t.timestamp,
                    hostname,
                    domain))

            logger.debug(
                "Writing backup for {} to {}".format(
                    hostname, filename))
            with open(filename, 'wb') as fout:
                fout.write(backup)

            if _verify_zip(filename):
                logger.info(
                    "backup for {} in {} domain verified".format(
                        hostname, domain))
                results[hostname + "-" + domain + "-normalBackup"] = "Verified"
            else:
                logger.info(
                    "backup for {} in {} domain corrupt".format(
                        hostname, domain))
                results[hostname + "-" + domain + "-normalBackup"] = "Corrupt"

    if web:
        return util.render_results_table(results), util.render_history(env)

    for k, v in results.items():
        print
        print k
        print '=' * len(k)
        print v
        print


@logged("mast.datapower.backups")
@cli.command('secure-backup', category='backups')
def get_secure_backup(appliances=[], credentials=[],
                      timeout=1200, out_dir='tmp',
                      CryptoCertificate="", destination='local:/raid0',
                      include_iscsi=False, include_raid=False,
                      remove=True, quiesce_before=True, unquiesce_after=True,
                      quiesce_timeout=60, no_check_hostname=False, web=False):
    """Performs a secure backup of the specified domain.

Parameters:

* out-dir - (NOT NEEDED IN WEB GUI) The directory (local) to store
the backup
* CryptoCertificate - The CryptoCertificate object to use to encrypt
the backup
* destination - The base location (on the appliance) to store
the backup
* include-iscsi - Whether to include the iscsi filesystem
* include-raid - Whether to include the RAID filesystem
* no-remove - If specified the backup will NOT be removed from
the DataPower
    """
    logger = make_logger("mast.backups")
    check_hostname = not no_check_hostname
    env = datapower.Environment(
        appliances,
        credentials,
        timeout,
        check_hostname=check_hostname)

    output = ""

    if quiesce_before:
        resp = {}
        for appliance in env.appliances:
            logger.info(
                "Quiescing {} in preparation of Secure Backup".format(
                    appliance.hostname))
            resp[appliance.hostname] = appliance.QuiesceDP(
                timeout=quiesce_timeout)
            logger.debug(
                "Response received {}".format(resp[appliance.hostname]))
            if web:
                output += util.render_boolean_results_table(
                    resp, suffix="Quiesce_appliance")
        sleep(quiesce_timeout)

    t = Timestamp()
    if destination.endswith("/"):
        destination = destination.rstrip("/")
    destination = '%s/%s' % (destination, t.timestamp)

    kwargs = {'Dir': destination, 'domain': 'default'}

    logger.info(
        "Creating directory {} on {} to store Secure Backup".format(
            destination, str(env.appliances)))
    resp = env.perform_async_action('CreateDir', **kwargs)
    logger.debug("Responses received {}".format(str(resp)))

    if web:
        output += util.render_boolean_results_table(resp, suffix="CreateDir")

    include_raid = 'on' if include_raid else 'off'
    include_iscsi = 'on' if include_iscsi else 'off'

    kwargs = {
        'cert': CryptoCertificate,
        'destination': destination,
        'include_iscsi': include_iscsi,
        'include_raid': include_raid}
    logger.info(
        "Attempting to perform a Secure Backup on {}".format(
            str(env.appliances)))
    resp = env.perform_async_action('SecureBackup', **kwargs)
    logger.debug("Responses received: {}".format(str(resp)))

    if web:
        output += util.render_boolean_results_table(
            resp, suffix="SecureBackup")

    if web:
        results = {}
        remove_results = {}
    for appliance in env.appliances:
        directory = os.path.join(
            out_dir,
            appliance.hostname,
            "SecureBackup",
            t.timestamp)

        start = time()
        while not appliance.file_exists(
                '{}/backupmanifest.xml'.format(
                    destination),
                'default'):
                sleep(5)
                if time() - start > timeout:
                    raise TimeoutError

        logger.info(
            "Attempting to retrieve Secure Backup from {}".format(
                appliance.hostname))
        appliance.copy_directory(
            destination,
            directory)

        _directory = os.path.join(
            directory, destination.replace(":", "").replace("///", "/"))

        try:
            logger.info(
                "Attempting to verify Secure Backup for {}".format(
                    appliance.hostname))
            if appliance.verify_local_backup(_directory):
                logger.info(
                    "Secure Backup integrity verified for {}".format(
                        appliance.hostname))
                if web:
                    results[appliance.hostname] = "Succeeded"
                else:
                    print '\t', appliance.hostname, " - ", "Succeeded"
                if remove:
                    logger.info(
                        "Attempting to remove Secure Backup from appliance "
                        "{}".format(
                            appliance.hostname))
                    _resp = appliance.RemoveDir(
                        Dir=destination, domain='default')
                    logger.debug("Response received: {}".format(_resp))
                    if web:
                        remove_results[appliance.hostname] = _resp
            else:
                logger.warn(
                    "Secure Backup for {} Corrupt!".format(
                        appliance.hostname))
                if web:
                    results[appliance.hostname] = "Failed"
                else:
                    print '\t', appliance.hostname, " - ", "Failed"
                appliance.log_error(
                    'Verification of backup in %s failed' % (_directory))
        except:
            if web:
                results[appliance.hostname] = "Failed"
            logger.exception(
                "An unhandled exception occurred during execution.")
    if web:
        output += util.render_results_table(
            results, suffix="verify-SecureBackup")
        output += util.render_boolean_results_table(
            remove_results, suffix="RemoveDir")

    if unquiesce_after:
        resp = {}
        for appliance in env.appliances:
            logger.info(
                "Attempting to unquiesce {}".format(
                    str(appliance.hostname)))
            resp[appliance.hostname] = appliance.UnquiesceDP()
            logger.debug(
                "Response received: {}".format(
                    resp[appliance.hostname]))
            if web:
                output += util.render_boolean_results_table(
                    resp, suffix="Unquiesce_appliance")

    if web:
        return output, util.render_history(env)


@logged("mast.datapower.backups")
@cli.command('restore-secure-backup', category='backups')
def restore_secure_backup(appliances=[], credentials=[], timeout=1200,
                          CryptoCertificate="", location="",
                          validate=True, no_check_hostname=False,
                          web=False):
    """Restores a secure backup to the specified appliances.

Parameters:

* CryptoCertificate - The CryptoCertificate object with which
to encrypt the secure backup
* location - The location on the appliances where the SecureBackup
resides (This means that you will have to upload the secure backup
if you got it from MAST)
* validate - If specified then the appliances will only attemp to
validate the backup instead of actually restoring it"""
    logger = make_logger("mast.backups")
    check_hostname = not no_check_hostname
    env = datapower.Environment(
        appliances,
        credentials,
        timeout,
        check_hostname=check_hostname)
    logger.info(
        "Attempting to restore Secure Backup on {}".format(
            str(env.appliances)))

    validate = "on" if validate else "off"

    kwargs = {
        "cred": CryptoCertificate,
        "source": location,
        "validate": "off"}
    if validate:
        kwargs["validate"] = "on"
    resp = env.perform_action("SecureRestore", **kwargs)
    logger.debug("Responses received: {}".format(str(resp)))

    if web:
        return (util.render_boolean_results_table(resp),
                util.render_history(env))

    for host, msg in resp.items():
        print host, '\n', "=" * len(host)
        print msg
        print


@logged("mast.datapower.backups")
@cli.command('list-checkpoints', category='checkpoints')
def list_checkpoints(appliances=[], credentials=[], timeout=120,
                     Domain="", no_check_hostname=False, web=False):
    """Lists the checkpoints which are currently in the
    specified domain"""
    logger = make_logger("mast.backups")
    check_hostname = not no_check_hostname
    env = datapower.Environment(
        appliances,
        credentials,
        timeout,
        check_hostname=check_hostname)
    logger.info(
        "Attempting to list checkpoints for {} in {} domain".format(
            str(env.appliances), Domain))

    resp = env.perform_action("get_existing_checkpoints", domain=Domain)
    logger.debug("Responses received: {}".format(str(resp)))
    if web:
        return (util.web_list_checkpoints(resp, Domain),
                util.render_history(env))

    for host, d in resp.items():
        print host, '\n', '=' * len(host)
        for key, value in d.items():
            print key, "-".join(value["date"]), ":".join(value["time"])
        print


@logged("mast.datapower.backups")
@cli.command('remove-checkpoint', category='checkpoints')
def remove_checkpoint(appliances=[], credentials=[], timeout=120,
                      Domain="", checkpoint_name="",
                      no_check_hostname=False, web=False):
    """Deletes a checkpoint from the specified domain

Parameters:

* Domain - The domain from which to delete the checkpoint
* checkpoint_name - The name of the checkpoint to remove"""
    logger = make_logger("mast.backups")
    check_hostname = not no_check_hostname
    env = datapower.Environment(
        appliances,
        credentials,
        timeout,
        check_hostname=check_hostname)
    logger.info(
        "Attempting to remove checkpoint {} from {} in {} domain".format(
            checkpoint_name,
            str(env.appliances),
            Domain))

    resp = env.perform_action(
        "RemoveCheckpoint", ChkName=checkpoint_name, domain=Domain)
    logger.debug("Responses received: {}".format(str(resp)))

    if web:
        return (util.render_boolean_results_table(resp),
                util.render_history(env))


@logged("mast.datapower.backups")
@cli.command('rollback-checkpoint', category='checkpoints')
def rollback_checkpoint(appliances=[], credentials=[], timeout=120,
                        Domain="", checkpoint_name="",
                        no_check_hostname=False, web=False):
    """Roll back the specified domain to the named checkpoint.

Parameters:

* Domain - The domain which to roll back
* checkpoint_name - The name of the checkpoint to roll back to"""
    logger = make_logger("mast.backups")
    check_hostname = not no_check_hostname
    env = datapower.Environment(
        appliances,
        credentials,
        timeout,
        check_hostname=check_hostname)
    logger.info(
        "Attempting to rollback checkpoint {} on {} in {} domain".format(
            checkpoint_name,
            str(env.appliances),
            Domain))

    resp = env.perform_action(
        "RollbackCheckpoint", ChkName=checkpoint_name, domain=Domain)
    logger.debug("Responses received: {}".format(str(resp)))

    if web:
        return (util.render_boolean_results_table(resp),
                util.render_history(env))


@logged("mast.datapower.backups")
@cli.command('set-checkpoint', category='checkpoints')
def set_checkpoint(appliances=[], credentials=[],
                   timeout=120, Domain=['default'],
                   comment='', remove_oldest=True,
                   no_check_hostname=False, web=False):
    """Sets a checkpoint in the given domains on the specified appliances

Parameters:

* Domain - a list of domains to set checkpoints in
* comment - The comment to use for the checkpoint (will also be used to
build the checkpoint name)
* remove_oldest - If specified this script will attempt to remove the oldest
checkpoint __IF__ the maximum number of checkpoints exist"""
    logger = make_logger("mast.backups")
    check_hostname = not no_check_hostname
    env = datapower.Environment(
        appliances,
        credentials,
        timeout,
        check_hostname=check_hostname)
    logger.info(
        "Attempting to set checkpoint on {} in {} domain(s)".format(
            str(env.appliances),
            str(Domain)))

    t = Timestamp()

    if web:
        header_row = ("Appliance", "Result")
        rows = []

    for appliance in env.appliances:
        for domain in Domain:
            name = '{0}-{1}-{2}'.format(comment, domain, t.timestamp)
            logger.debug(
                "Attempting to set checkpoint {} on {} in {} domain".format(
                    name,
                    appliance,
                    domain))
            if remove_oldest:
                _max = appliance.max_checkpoints(domain)
                if len(appliance.get_existing_checkpoints(domain)) >= _max:
                    logger.info(
                        "Maximum number of checkpoints for domain "
                        "{} on {} reached. Removing oldest checkpoint.".format(
                            domain, appliance.hostname))
                    _resp = appliance.remove_oldest_checkpoint(domain)
                    logger.debug("Response received: {}".format(_resp))
            kwargs = {'domain': domain, 'ChkName': name}
            resp = appliance.SaveCheckpoint(**kwargs)
            logger.debug("Response received: {}".format(resp))
            if web:
                if resp:
                    rows.append((
                        "{}-{}-set_checkpoint".format(
                            appliance.hostname, domain),
                        "Succeeded"))
                else:
                    rows.append((
                        "{}-{}-set_checkpoint".format(
                            appliance.hostname, domain),
                        "Failed"))
    if web:
        return flask.render_template(
            "results_table.html",
            header_row=header_row,
            rows=rows), util.render_history(env)
#
# ~#~#~#~#~#~#~#


def get_data_file(f):
    _root = os.path.dirname(__file__)
    path = os.path.join(_root, "data", f)
    with open(path, "rb") as fin:
        return fin.read()


class WebPlugin(Plugin):
    def __init__(self):
        self.route = partial(pf.handle, "backups")
        self.route.__name__ = "backups"
        self.html = partial(pf.html, "mast.datapower.backups")
        update_wrapper(self.html, pf.html)

    def css(self):
        return get_data_file('plugin.css')

    def js(self):
        return get_data_file('plugin.js')


if __name__ == '__main__':
    try:
        cli.Run()
    except AttributeError, e:
        if "'NoneType' object has no attribute 'app'" in e:
            raise NotImplementedError(
                "HTML formatted output is not supported on the CLI")
